const constWidth = 1200;
const constHeight = 700
var canvas;

var state;
var currentRadius;
var isSetup;
var finished;
var amountCircles;
var circles = [];
var pxlArray;

const DO_NOTHING = 0;
const DRAW_CIRCLES = -3;
const GENERATE_CIRCLES = -2;
const RESET = -1;
const CIRCLE_MODE = 1;

const PXL_STATE_EMPTY = 0;
const STANDART_PXL_COLOR = "1e1e1e";
const BORDER_PXL_COLOR = "fffff";
const PIXEL_ACTIVE_COLOR = "fffff"
const PXL_STATE_BORDER = -1;

function setup() {
    isSetup = true;
    stopCounter = 0;
    finished = false;

    pxlArray = createPxlArray(constWidth, constHeight);
    for (x = 0; x < constWidth; x++) {
        for (y = 0; y < constWidth; y++) {
            pxlArray[x][y] = new Pixel(PXL_STATE_EMPTY, STANDART_PXL_COLOR)
        }
    }

    canvas = createCanvas(constWidth, constHeight);
    canvas.parent("canvas");
    angleMode(DEGREES);
    frameRate(60);

    background('#1e1e1e');

    currentRadius = 0;

    if (!amountCircles) {
        //default value amount cirlces
        amountCircles = 10;
        state = GENERATE_CIRCLES
    } else {
        state = DRAW_CIRCLES
    }
}

function draw() {
    var fps = frameRate();

    //point(mouseX, mouseY);
    //DrawCirle(300, 300, 100);

    //ellipse(mouseX, mouseY, 80, 80);
    if (state == DO_NOTHING) {

    } else if (state == GENERATE_CIRCLES) {
        generateCirclesFun();
    } else if (state == CIRCLE_MODE) {
        isSetup = false;
        circleModeFun();
    } else if (state == RESET) {
        state = DO_NOTHING;
        setup();
    } else if (state == DRAW_CIRCLES) {
        background('#1e1e1e');
        console.log("draw random cirlces");
        for (var i = 0; i < circles.length; i++) {
            point(circles[i].getCenterX(), circles[i].getCenterY());
        }
        state = DO_NOTHING;
    }
    stroke(255);
    text("FPS: " + fps.toFixed(2) + " / 60.00", 10, height - 10);
}

function generateCirclesFun() {
    circles = [];
    for (var i = 0; i < amountCircles; i++) {
        var cirlce = new Circle(Math.floor((Math.random() * constWidth) + 0), Math.floor((Math.random() * constHeight) + 0), 0, STANDART_PXL_COLOR);
        circles.push(cirlce);
    }
    state = DRAW_CIRCLES;
}

function circleModeFun() {
    if (currentRadius <= constHeight && CIRCLE_MODE == 1) {
        for (var i = 0; i < circles.length; i++) {
            DrawCircleInArray(circles[i].getCenterX(), circles[i].getCenterY(), currentRadius, STANDART_PXL_COLOR);
            //DrawCirle(circles[i].getCenterX(), circles[i].getCenterY(), currentRadius);
        }
        drawPxlArrayToCanavas(currentRadius);
        //updatePixels();

        currentRadius += 1;
    } else {
        currentRadius = 1;
        finish();
        //setup();
    }
}

function finish() {
    finished = true;
    state = DO_NOTHING;
}


var DrawCircleInArray = function (x0, y0, radius, color) {
    var x = radius;
    var y = 0;
    var radiusError = 1 - x;

    while (x >= y) {
        setPixelInArray(x + x0, y + y0, radius, color);
        setPixelInArray(x + x0 + 1, y + y0, radius, color);

        setPixelInArray(y + x0, x + y0, radius, color);
        setPixelInArray(y + x0 + 1, x + y0, radius, color);

        setPixelInArray(-x + x0, y + y0, radius, color);
        setPixelInArray(-x + x0 - 1, y + y0, radius, color);

        setPixelInArray(-y + x0, x + y0, radius, color);
        setPixelInArray(-y + x0 - 1, x + y0, radius, color);

        setPixelInArray(-x + x0, -y + y0, radius, color);
        setPixelInArray(-x + x0 - 1, -y + y0, radius, color);

        setPixelInArray(-y + x0, -x + y0, radius, color);
        setPixelInArray(-y + x0 - 1, -x + y0, radius, color);

        setPixelInArray(x + x0, -y + y0, radius, color);
        setPixelInArray(x + x0 + 1, -y + y0, radius, color);

        setPixelInArray(y + x0, -x + y0, radius, color);
        setPixelInArray(y + x0 + 1, -x + y0, radius, color);

        y++;

        if (radiusError < 0) {
            radiusError += 2 * y + 1;
        }
        else {
            x--;
            radiusError += 2 * (y - x + 1);
        }
    }
}

var setPixelInArray = function (x, y, state, color) {
    if(x >= 0 && x < constWidth && y >= 0 && y < constHeight){
        var pxl = pxlArray[x][y];
        if (pxl.getState() == state || pxl.getState() == PXL_STATE_BORDER) {
            //detect if border Pixel
            pxl.setState(PXL_STATE_BORDER);
            pxl.setColor(BORDER_PXL_COLOR);
        } else if (pxl.getState() == PXL_STATE_EMPTY) {
            //detect if Pixel emtpy
            pxl.setState(state);
            pxl.setColor(color);
        }
    }
}

var drawPxlArrayToCanavas = function(currentRadius){
    //todo replace with pixel
    background('#1e1e1e');
    stroke(255);
    loadPixels();
    for(y = 0; y < constHeight; y++){
        for(x = 0; x < constWidth; x++){
            var tmpPixelState = pxlArray[x][y].getState();
            //console.log(tmpPixelState != PXL_STATE_EMPTY && tmpPixelState == currentRadius);
            if(tmpPixelState != PXL_STATE_EMPTY && tmpPixelState == currentRadius){
                //set(x, y, color(255));
                var index = ((x + y * constWidth)*4)*pixelDensity();
                pixels[index] = 255;
                pixels[index +1] = 255;
                pixels[index+2] = 255;
                pixels[index+3] = 255;
                
            } else if(tmpPixelState == PXL_STATE_BORDER){
                var index = ((x + y * constWidth)*4)*pixelDensity();
                pixels[index] = 255;
                pixels[index +1] = 255;
                pixels[index+2] = 255;
                pixels[index+3] = 255;
            }
        }
    }
    updatePixels();
}

var setPixelInCanvas = function(x, y, color){
    
}

var DrawCirle = function (x0, y0, radius) {

    noStroke();
    //point(x0, y0);

    var x = radius;
    var y = 0;
    var radiusError = 1 - x;
    //tmp
    var white = color(255);
    while (x >= y) {

        set(x + x0, y + y0, white);
        set(x + x0 + 1, y + y0, white);

        set(y + x0, x + y0, white);
        set(y + x0 + 1, x + y0, white);

        set(-x + x0, y + y0, white);
        set(-x + x0 - 1, y + y0, white);

        set(-y + x0, x + y0, white);
        set(-y + x0 - 1, x + y0, white);

        set(-x + x0, -y + y0, white);
        set(-x + x0 - 1, -y + y0, white);

        set(-y + x0, -x + y0, white);
        set(-y + x0 - 1, -x + y0, white);

        set(x + x0, -y + y0, white);
        set(x + x0 + 1, -y + y0, white);

        set(y + x0, -x + y0, white);
        set(y + x0 + 1, -x + y0, white);

        y++;

        if (radiusError < 0) {
            radiusError += 2 * y + 1;
        }
        else {
            x--;
            radiusError += 2 * (y - x + 1);
        }
    }
};

function createPxlArray(length) {
    var arr = new Array(length || 0),
        i = length;
    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while (i--) arr[length - 1 - i] = createPxlArray.apply(this, args);
    }
    return arr;
}
